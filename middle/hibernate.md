# HIBERNATE

1) [Что такое ORM?](#что-такое-orm)
2) [Опиши, как конфигурируется Hibernate. Рассказать про hibernate.cfg.xml и про mapping.](#опиши-как-конфигурируется-hibernate-рассказать-про-hibernatecfgxml-и-про-mapping)
3) [Жизненный цикл Entity.](#жизненный-цикл-entity)
4) [Зачем нужен класс SessionFactory? Является ли он потокобезопасным?](#зачем-нужен-класс-sessionfactory-является-ли-он-потокобезопасным)
5) [Зачем нужен класс Session? Является ли он потокобезопасным?](#зачем-нужен-класс-session-является-ли-он-потокобезопасным)
6) [В чем отличие методов Session.get Session.load?](#в-чем-отличие-методов-sessionget-sessionload)
7) [Расскажите про методы flush close.](#расскажите-про-методы-flush-close)
8) [В чем отличие методы save от saveOrUpdate и merge?](#в-чем-отличие-методы-save-от-saveorupdate-и-merge)
9) [Расскажите процесс создания, редактирования, чтения и удаления данных через Hibernate.](#расскажите-процесс-создания-редактирования-чтения-и-удаления-данных-через-hibernate)
10) [Как осуществляется иерархия наследования в Hibernate? Рассказать про три стратегии наследования.](#как-осуществляется-иерархия-наследования-в-hibernate-рассказать-про-три-стратегии-наследования)
11) [Можно ли создать собственный тип данных?](#можно-ли-создать-собственный-тип-данных)
12) [Какие коллекции поддерживаются на уровне mapping?](#какие-коллекции-поддерживаются-на-уровне-mapping)
13) [Зачем нужен класс Transactional?](#зачем-нужен-класс-transactional)
14) [Расскажите про уровни изоляции? Какие уровни поддерживаются в hibernate? Как их устанавливать?](#расскажите-про-уровни-изоляции-какие-уровни-поддерживаются-в-hibernate-как-их-устанавливать)
15) [Что такое OplimisticLock? Расскажите стратегии создания через version, timestamp.](#что-такое-oplimisticlock-расскажите-стратегии-создания-через-version-timestamp)
16) [Расскажите про стратегии извлечения данных urgy, lazy?](#расскажите-про-стратегии-извлечения-данных-urgy-lazy)
17) [Что такое объект Proxy? С чем связана ошибка LazyInitializationException? Как ее избежать?](#что-такое-объект-proxy-с-чем-связана-ошибка-lazyinitializationexception-как-ее-избежать)
18) [HQL. Расскажи основные элементы синтаксиса HQL? Простой запрос, запрос join? Создания объекта через конструктор.](#hql-расскажи-основные-элементы-синтаксиса-hql-простой-запрос-запрос-join-создания-объекта-через-конструктор)
19) [Расскажите про уровни кешей в Hibernate?](#расскажите-про-уровни-кешей-в-hibernate)
20) [Что такое StatelessSessionFactory? Зачем он нужен, где он используется?](#что-такое-statelesssessionfactory-зачем-он-нужен-где-он-используется)
21) [Зачем нужен решим read-only?](#зачем-нужен-решим-read-only)
22) [Расскажите, какие шаблоны проектирования используется в Hibernate (factory, proxy, strategy)](#расскажите-какие-шаблоны-проектирования-используется-в-hibernate-factory-proxy-strategy)

## Что такое orm
ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение, или преобразование) — технология программирования,
которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных»

т.е. ORM — прослойка между базой данных и кодом который пишет программист, которая позволяет созданые в программе объекты складывать/получать в/из бд.

## В чем отличие JPA от Hibernate?
JPA - это спецификация JavaEE, а Hibernate - это ORM фреймворк/библиотека, которая совместима с JPA. Как и в классическом ООП, класс, который реализует интерфейс, может иметь дополнительные методы/свойства, так и Hiberante имеет больше фичей чем JPA.

JPA определяет:
- способ определения метаданных отображений - как хранимые классы и их свойства соотносятся со схемой бд. JPA широко использует Java-аннотации в классах предметной модели, но вы можете определить отображения при помощи XML;
- API для основных CRUD-операций, производимых над экземплярами хранимых классов, наиболее известен класс EntityManager, используемый для сохранения и загрузки данных;
- язык и API для создания запросов, использующих классы и их свойства. Этот язык называется Java Persistence Query Language(JPQL) и очень похож на SQL. Стандартизированный API позволяет программно создавать запросы с критериями без работы со строковыми значениями;
- порядок взаимодействия механизма хранения с транзакционными сущностями для сравнения состояний объектов, извлечения ассоциаций и выполнения прочих оптимизаций. Кроме того, в последней спецификации JPA рассмотрены основные стратегии кэширования. 

## Что такое Entity и какие есть требование к Entity в JPA?
Entity (Сущность) — POJO-класс, связанный с БД с помощью аннотации (@Entity) или через XML. К такому классу предъявляются следующие требования: Должен иметь пустой конструктор (public или protected) Не может быть вложенным, интерфейсом или enum.

1) Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
2) Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами),
3) Entity класс не может быть enum или интерфейсом,
4) Entity класс не может быть финальным классом (final class),
5) Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),
6) Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс,
7) Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),
8) Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных


## Какие есть состояния Entity в Hibernate?

org.hibernate.Session  и javax.persistence.EntityManager  представляют контекст для работы с постоянно хранимыми данными. Этот контекст называется persistence context. Сохраняемые данные имеют свою состояние как относительно persistence context, так и относительно базы данных. Сущность Hibernate может находиться в одном из четырёх состояний:

```transient\new``` — экземпляр сущности был создан, но не связан с persistence context. Он не сохранён в базе данных и обычно не имеет идентификатора.

```managed``` или ```persistent``` — сущность связана с persistence context и имеет связанный с ней идентификатор. Она может как существовать в базе данных, так и пока отсутствовать в ней.

```detached``` — с сущностью связан идентификатор, но она больше не связана с persistence context (обычно из-за того, что persistence context был закрыт, либо экземпляр был удалён из него)

```removed``` — сущность имеет идентификатор и связана с persistence context, но она запланирована к удалению из базы данных.

## Какие есть стратегии наследования Entity в Hibernate?
SQL не понимает наследование типов и не поддерживает его.

Поэтому на этапе построения сущностей и схемы БД одной из главных задач разработчика будет выбор оптимальной стратегии представления иерархии наследования.

Всего таких стратегий 4:

1) Использовать одну таблицу для каждого класса и полиморфное поведение по умолчанию.
2) Одна таблица для каждого конкретного класса, с полным исключением полиморфизма и отношений наследования из схемы SQL (для полиморфного поведения во время выполнения будут использоваться UNION-запросы)
```java
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
```
3) Единая таблица для всей иерархии классов. Возможна только за счет денормализации схемы SQL. Определять суперкласс и подклассы будет возможно посредством различия строк.
```java
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
```
4) Одна таблица для каждого подкласса, где отношение “is a” представлено в виде «has a», т.е. – связь по внешнему ключу с использованием JOIN.
```java
@Inheritance(strategy = InheritanceType.JOINED)
```

## Что такое сессия в Hibernate?
В Hibernate работа с БД осуществляется через объект типа org.hibernate.Session.
Интерфейс org.hibernate.Session является мостом между приложением и Hibernate. С помощью сессий выполняются все CRUD-операции с объектами-сущностями. Объект типа Session получают из экземпляра типа org.hibernate.SessionFactory, который должен присутствовать в приложении в виде singleton.

[https://habr.com/ru/post/337488/](https://habr.com/ru/post/337488/)

## Уровни кэширования в Hibernate.
Довольно часто в java приложениях с целью снижения нагрузки на БД используют кеш.

Прежде всего Hibernate cache — это 3 уровня кеширования:
- Кеш первого уровня (First-level cache);
- Кеш второго уровня (Second-level cache);
- Кеш запросов (Query cache);

```Кеш первого уровня``` всегда привязан к объекту сессии. Hibernate всегда по умолчанию использует этот кеш и его нельзя отключить.

```Кеш второго уровня```

Если кеш первого уровня привязан к объекту сессии, то кеш второго уровня привязан к объекту-фабрике сессий (Session Factory object). Что как бы подразумевает, что видимость этого кеша гораздо шире кеша первого уровня. По умолчанию кеш второго уровня отключен. Для включения необходимо добавить следующие строки в Вашем конфигурационном файле JPA (persistence.xml):
```xml
<property name="hibernate.cache.provider_class" value="net.sf.ehcache.hibernate.SingletonEhCacheProvider"/>
//или в более старых версиях
//<property name="hibernate.cache.provider_class" value="org.hibernate.cache.EhCacheProvider"/>
<property name="hibernate.cache.use_second_level_cache" value="true"/>
```
```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Foo {}
```

Обратите внимание на первую строку. На самом деле, хибернейт сам не реализует кеширование как таковое. А лишь предоставляет структуру для его реализации, поэтому подключить можно любую реализацию, которая соответствует спецификации нашего ORM фреймворка. Из популярных реализаций можно выделить следующие:
- EHCache
- OSCache
- SwarmCache
- JBoss TreeCache
  
Чтение из кеша второго уровня происходит только в том случае, если нужный объект не был найден в кеше первого уровня.

```Кеш запросов```
```java
Query query = session.createQuery("from SharedDoc doc where doc.name = :name");

SharedDoc persistedDoc = (SharedDoc) query.setParameter("name", "first").uniqueResult();
System.out.println(persistedDoc.getName());
user1.setDoc(persistedDoc);

persistedDoc = (SharedDoc) query.setParameter("name", "first").uniqueResult();
System.out.println(persistedDoc.getName());
user2.setDoc(persistedDoc);
```
Результаты такого рода запросов не сохраняются ни кешом первого, ни второго уровня. Это как раз то место, где можно использовать кеш запросов. Он тоже по умолчанию отключен.
Для включения нужно добавить следующую строку в конфигурационный файл:
```xml
<property name="hibernate.cache.use_query_cache" value="true"/>
```

а также переписать пример выше добавив после создания объекта Query (то же справедливо и для Criteria):
```java
Query query = session.createQuery("from SharedDoc doc where doc.name = :name");
query.setCacheable(true);
```

Кеш запросов похож на кеш второго уровня. Но в отличии от него — ключом к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса. А сами данные — это идентификаторы объектов соответствующих критериям запроса. Таким образом, этот кеш рационально использовать с кешем второго уровня.

[https://habr.com/ru/post/135176/](https://habr.com/ru/post/135176/)

##Пессимистичные и оптимистичные локи в Hibernate
Блокировка — это механизм, позволяющий параллельно работать с одними и теми же данными в базе данных. Когда несколько транзакций одновременно пытаются получить доступ к одним и тем же данным, вступают в действие блокировки, которые гарантируют, что только одна из этих транзакций изменит данные. JPA поддерживает два типа механизмов блокировки: оптимистическую модель и пессимистическую модель.

- Оптимистичная

Оптимистичные блокировки предполагают, что множество транзакций могут завершиться без влияния друг на друга, и таким образом могут выполнятся без блокировок тех ресурсов, на которые они влияют. Перед коммитом, каждая транзакция проверяет, что ни одна другая транзакция не модифицировала ее данные. Если проверка выявила конфликтующие модификации, транзакция, находящаяся в состоянии коммита, откатывается.

Вы можете хранить версионированные данные, когда ваше приложение использует долгоживущие транзакции или диалоги, покрывающие несколько БД-транзакций. Таким образом, если одна и та же сущность будет модифицироваться двумя диалогами, последний диалог, коммитивший изменения, будет оповещен о конфликте, и не перезапишет результаты другого диалога. Этот подход гарантирует некоторую степень изоляции, но при этом хорошо масштабируется, и довольно неплохо себя показывает в ситуациях Read-Often Write-Sometimes
Hibernate предоставляет два различных механизма для хранения версионной информации – выделенный номер версии, или временную метку (timestamp).

Механизм номера версии для оптимистичных блокировок предоставляется аннотацией Version.
```java
@Entity
public class Flight implements Serializable {
...
@Version
@Column(name="OPTLOCK")
public Integer getVersion() { ... }
}
```

Временные метки (timestamps) — менее надежный способ оптимистичных блокировок чем номера версий, который также может быть использован приложениями для других целей. Временные метки используются автоматически, если вы используете аннотацию Version на свойстве типа Date или Calendar.
```java
@Entity
public class Flight implements Serializable {
...
@Version
public Date getLastUpdate() { ... }

```

- Пессимистичная

Пессимистичная стратегия подразумевает, что параллельные транзакции будут конфликтовать каждая друг с другом, и требует блокировки ресурсов после их чтения, а также ее снятия только после того, как приложение завершило использование данных.
Hibernate предоставляет механизмы для реализации обеих стратегий блокировок в вашем приложении.

Класс LockMode определяет различные уровни блокировок, которые может захватывать Hibernate.

- LockMode.WRITE
Захватывается автоматически, когда Hibernate обновляет или вставляет строку.
- LockMode.UPGRADE
Захватывается после явного запроса пользователя с использованием SELECT… FOR UPDATE на БД, поддерживающих данный синтаксис.
- LockMode.UPGRADE_NOWAIT
Захватывается после явного запроса пользователя с использованием SELECT… FOR UPDATE NOWAIT в Oracle
- LockMode.READ
Захватывается автоматически когда Hibernate читает данные под уровнями изоляции Repeatable Read или Serializable. Может быть повторно захвачен явным запросом пользователя.
- LockMode.NONE
Отсутствие блокировки. Все объекты переключаются на этот режим блокировки в конце транзакции. Объекты, ассоциированные с сессией
через вызов update() или saveOrUpdate также начинают в этом режиме.

Явный запрос пользователя, обозначенный выше, происходит как следствие любых из следующих действий:
- Вызов Session.load(), с указанием LockMode
- Вызов Session.lock()
- Вызов Query.setLockMode()

## Проблема N+1 и как ее решать
Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса.

Проблема заключается в выполнении множества дополнительных запросов, которые в сумме выполняются уже существенное время, влияющее на быстродействие.

 Данную проблему можно получить как на чистом SQL, так и с использованием технологий.

Использование явного или неявного FetchType.EAGER для JPA-ассоциаций — плохая идея, потому что будет загружаться гораздо больше данных, чем вам нужно. Более того, стратегия FetchType.EAGER также подвержена проблемам N + 1.

К сожалению, ассоциации @ManyToOne и @OneToOne по умолчанию используют FetchType.EAGER

Поэтому по умолчанию лучше использовать FetchType.LAZY.
использовать JOIN FETCH, чтобы избежать проблемы с N + 1

Даже если вы явно перейдете на использование FetchType.LAZY для всех ассоциаций, то вы все равно можете столкнуться с проблемой N + 1. Так как при запросу к данным, сгенерируются запросы 

Решение:
![img.png](img/n+1.png)

## Виды связей между таблицами в Hibernate и JPA?
Односторонние и двусторонние отношения в Hibernate
- OneToOne - один к одному
- OneToMany - один ко многим
- ManyToOne - многие к одному
- ManyToMany - многие ко многим

[к оглавлению](#hibernate)

## Опиши как конфигурируется hibernate рассказать про hibernatecfgxml и про mapping

Существует четыре способа конфигурации работы с Hibernate:
+ используя аннотации;
+ hibernate.cfg.xml;
+ hibernate.properties;
+ persistence.xml.

Самый частый способ конфигурации: через аннотации и файл persistence.xml,
что касается файлов hibernate.properties и hibernate.cfg.xml, то hibernate.cfg.xml главнее (если в приложение есть оба файла,
то принимаются настройки из файла hibernate.cfg.xml). Конфигурация аннотациями,
хоть и удобна, но не всегда возможна, к примеру, если для разных баз данных или для разных ситуаций
вы хотите иметь разные конфигурацию сущностей, то следует использовать xml файлы конфигураций.

Файл конфигурации Hibernate содержит в себе данные о базе данных и необходим для инициализации SessionFactory.
В .xml файле необходимо указать вендора базы данных или JNDI ресурсы, а так же информацию об используемом диалекте,
что поможет hibernate выбрать режим работы с конкретной базой данных.

Файл отображения (mapping file) используется для связи entity бинов и колонок в таблице базы данных.
В случаях, когда не используются аннотации JPA, файл отображения .xml может быть полезен (например при использовании сторонних библиотек).

[к оглавлению](#hibernate)
## Жизненный цикл entity

+ *Transient:* состояние, при котором объект никогда не был связан с какой-либо сессией и не является персистентностью. Этот объект находится во временном состоянии. Объект в этом состоянии может стать персистентным при вызове метода save(), persist() или saveOrUpdate(). Объект персистентности может перейти в transient состоянии после вызова метода delete().Экземпляр сущности был создан, но не ассоциирован в контекстом постоянства. Он не имеет отображения в базе данных, и как правило, не имеет id;
+ *Persistent:* когда объект связан с уникальной сессией он находится в состоянии persistent (персистентности). Любой экземпляр, возвращаемый методами get() или load() находится в состоянии persistent. Объект имеет id и ассоциирован с контекстом постоянства. Может иметь или не иметь отображения в БД;
+ *Detached:* если объект был персистентным, но сейчас не связан с какой-либо сессией, то он находится в отвязанном (detached) состоянии. Такой объект можно сделать персистентным используя методы update(), saveOrUpdate(), lock() или replicate(). Состояния transient или detached так же могут перейти в состояние persistent как новый объект персистентности после вызова метода merge().
+ *Removed:* Объект имеет id и ассоциирован с контекстом постоянства, но запланирован на удаление из базы данных при выполнении flush() или commit();

![img.png](img/cicly-entity.png)


[к оглавлению](#hibernate)
## Зачем нужен класс sessionfactory является ли он потокобезопасным

[к оглавлению](#hibernate)
## Зачем нужен класс session является ли он потокобезопасным

[к оглавлению](#hibernate)
## В чем отличие методов sessionget sessionload

[к оглавлению](#hibernate)
## Расскажите про методы flush close

[к оглавлению](#hibernate)
## В чем отличие методы save от saveorupdate и merge

[к оглавлению](#hibernate)
## Расскажите процесс создания редактирования чтения и удаления данных через hibernate

[к оглавлению](#hibernate)
## Как осуществляется иерархия наследования в hibernate рассказать про три стратегии наследования

[к оглавлению](#hibernate)
## Можно ли создать собственный тип данных

[к оглавлению](#hibernate)
## Какие коллекции поддерживаются на уровне mapping

[к оглавлению](#hibernate)
## Зачем нужен класс transactional

[к оглавлению](#hibernate)
## Расскажите про уровни изоляции какие уровни поддерживаются в hibernate как их устанавливать

[к оглавлению](#hibernate)
## Что такое oplimisticlock расскажите стратегии создания через version timestamp

[к оглавлению](#hibernate)
## Расскажите про стратегии извлечения данных urgy lazy

[к оглавлению](#hibernate)
## Что такое объект proxy с чем связана ошибка lazyinitializationexception как ее избежать

[к оглавлению](#hibernate)
## Hql расскажи основные элементы синтаксиса hql простой запрос запрос join создания объекта через конструктор

[к оглавлению](#hibernate)
## Расскажите про уровни кешей в hibernate

[к оглавлению](#hibernate)
## Что такое statelesssessionfactory зачем он нужен где он используется

[к оглавлению](#hibernate)
## Зачем нужен решим read only

[к оглавлению](#hibernate)
## Расскажите какие шаблоны проектирования используется в hibernate factory proxy strategy

[к оглавлению](#hibernate)
