## multithreading

1) [Чем отличается процесс от потока?](#чем-отличается-процесс-от-потока)
2) [Каким образом можно создать поток?](#каким-образом-можно-создать-поток)
3) [Как работают методы sleep, yield, wait, notify и notifyAll?](#как-работают-методы-sleep-yield-wait-notify-и-notifyall)
4) [Объясните следующие термины: монитор, мьютекс, критическая секция.](#объясните-следующие-термины-монитор-мьютекс-критическая-секция)
5) [Как работает join()?](#как-работает-join)
6) [Что такое DeadLock? Приведите примеры.](#что-такое-deadlock-приведите-примеры)
7) [Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.](#назовите-различия-между-collectionssynchronizedmap-new-hashmap-и-concurrenthashmap)
8) [Различия в интерфейсах Runnable и Callable.](#различия-в-интерфейсах-runnable-и-callable)
9) [Различия между isInterrupted(), interrupted().](#различия-между-isinterrupted-interrupted)
10) [Что происходит при вызове Thread.interrupt()?](#что-происходит-при-вызове-threadinterrupt)
11) [Перечислите ВСЕ причины по которым может выскочить InterruptedException.](#перечислите-все-причины-по-которым-может-выскочить-interruptedexception)
12) [Назовите отличия synchronize{} и ReentrantLock.](#назовите-отличия-synchronize-и-reentrantlock)
13) [Приведите наиболее существенное отличие между CountDownLatch и Barrier.](#приведите-наиболее-существенное-отличие-между-countdownlatch-и-barrier)
14) [Отличие Thread.start() и Thread.run()?](#отличие-threadstart-и-threadrun)
15) [Объясните ключевое слово volatile.](#объясните-ключевое-слово-volatile)
16) [Расскажите про приоритеты потока.](#расскажите-про-приоритеты-потока)
17) [Что такое потоки-демоны?](#что-такое-потоки-демоны)
18) [Назовите все возможные состояния потока.](#назовите-все-возможные-состояния-потока)
19) [Что такое race condition?](#что-такое-race-condition)
20) [Что такое Thread Local переменная?](#что-такое-thread-local-переменная)
21) [Что такое FutureTask?](#что-такое-futuretask)
22) [Что такое Thread Pool?](#что-такое-thread-pool)
23) [Что такое Semaphore?](#что-такое-semaphore)
24) [Чем отличается submit от execute у ExecutorServices?](#чем-отличается-submit-от-execute-у-executorservices)
25) [Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#чем-отличается-shutdown-от-shutdownnow-у-threadpoolexecutor)
26) [Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков.](#как-создать-threadpool-у-executorservice-только-на-1-на-5-на-неограниченное-количество-потоков)
27) [Что такое ReadWriteLock?](#что-такое-readwritelock)
28) [В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel().](#в-чём-отличие-thread-от-futuretask-в-чём-отличие-threadinterrupt-и-futuretaskcancel)
29) [Расскажите про шаблон проектирования Producer Consumer.](#расскажите-про-шаблон-проектирования-producer-consumer)


## Чем отличается процесс от потока
**Процесс** - это Отдельно запущенное приложение и у него есть своя область памяти (минимум 1 поток).

**Поток** - это параллельные нити выполнения внутри одного процесса которые разделяют общую память.

```Процесс``` — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие. Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.

Поток использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Как правило, каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.

```Поток``` — определенный способ выполнения процесса. Когда один поток изменяет ресурс процесса, это изменение сразу же становится видно другим потокам этого процесса.

[к оглавлению](#multithreading)

## Каким образом можно создать поток

Для создания нового потока мы можем создать новый класс, либо наследуя его от класса Thread, либо реализуя в классе интерфейс Runnable.

```java
class JThread extends Thread {
      
    JThread(String name){
        super(name);
    }
      
    public void run(){
          
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        try{
            Thread.sleep(500);
        }
        catch(InterruptedException e){
            System.out.println("Thread has been interrupted");
        }
        System.out.printf("%s fiished... \n", Thread.currentThread().getName());
    }
}
```

Класс потока называется JThread. Предполагается, что в конструктор класса передается имя потока, которое затем передается в конструктор базового класса. В конструктор своего класса потока мы можем передать различные данные, но главное, чтобы в нем вызывался конструктор базового класса Thread, в который передается имя потока.

И также в JThread переопределяется метод run(), код которого собственно и будет представлять весь тот код, который выполняется в потоке.

В методе main для запуска потока JThread у него вызывается метод start(), после чего начинается выполнение того кода, который определен в методе run:

```java
new JThread("JThread").start();
```


Другой способ определения потока представляет реализация интерфейса Runnable. Этот интерфейс имеет один метод run:

```java
class MyThread implements Runnable {
      
     
    public void run(){
          
        System.out.printf("%s started... \n", Thread.currentThread().getName());
        try{
            Thread.sleep(500);
        }
        catch(InterruptedException e){
            System.out.println("Thread has been interrupted");
        }
        System.out.printf("%s finished... \n", Thread.currentThread().getName());
    }
} 
```

Реализация интерфейса Runnable во многом аналогична переопределению класса Thread.

Поскольку Runnable фактически представляет функциональный интерфейс, который определяет один метод, то объект этого интерфейса мы можем представить в виде лямбда-выражения:

```java
public class Program {
  
    public static void main(String[] args) {
          
        System.out.println("Main thread started...");
        Runnable r = ()->{
            System.out.printf("%s started... \n", Thread.currentThread().getName());
            try{
                Thread.sleep(500);
            }
            catch(InterruptedException e){
                System.out.println("Thread has been interrupted");
            }
            System.out.printf("%s finished... \n", Thread.currentThread().getName());
        };
        Thread myThread = new Thread(r,"MyThread");
        myThread.start();
        System.out.println("Main thread finished...");
    }
}
```

Thread имплементирует Runnable


  Очень часто при работе с потоками нам нужно получать какой-то результат и было бы очень удобно, чтобы поток сам возвращал результаты своей работы. Именно поэтому еще в Java 5 был введен интерфейс  java.util.concurrent.Callable. Он очень похож на интерфейс Runnable, но может вернуть результат в виде объекта Object и способен бросать исключения.

Интерфейс Callable использует дженерики для определения типа возвращаемого объекта. Класс Executors предоставляет полезные методы для выполнения Callable в пуле потоков. Callable таски (задачи) возвращают java.util.concurrent.Future объект. Используя Future мы можем узнать статус Callable таска и получить возвращенный объект. Это обеспечивает get() метод, который ждет завершение Callable, чтобы вернуть результат.

Future обеспечивает метод cancel() для отмены Callable таска. Есть перегруженный вариант метода get(), где мы можем указать время ожидания результата, это нужно для избежания блокировки текущего потока на длительное время. Также есть методы isDone() и isCancelled(), которые используются для получения статуса ассоциированного Callable таска.

Вот простой пример использования Callable таска, который возвращает имя потока. В примере используется Executor framework для одновременного выполнения 100 задач и Future, чтобы получить результат выполнения:

```java
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
 
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
 
public class MyCallable implements Callable<String> {
 
    @Override
    public String call() throws Exception {
        Thread.sleep(1000);
        // возвращает имя потока, который выполняет callable таск
        return Thread.currentThread().getName();
    }
     
    public static void main(String args[]){
        //Получаем ExecutorService утилитного класса Executors с размером пула потоков равному 10
        ExecutorService executor = Executors.newFixedThreadPool(10);
        //создаем список с Future, которые ассоциированы с Callable
        List<Future<String>> list = new ArrayList<Future<String>>();
        // создаем экземпляр MyCallable
        Callable<String> callable = new MyCallable();
        for(int i=0; i< 100; i++){
            //сабмитим Callable таски, которые будут 
            //выполнены пулом потоков
            Future<String> future = executor.submit(callable);
            //добавляя Future в список, 
            //мы сможем получить результат выполнения
            list.add(future);
        }
        for(Future<String> fut : list){
            try {
                // печатаем в консоль возвращенное значение Future
                // будет задержка в 1 секунду, потому что Future.get()
                // ждет пока таск закончит выполнение
                System.out.println(new Date()+ "::" + fut.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }
        
        executor.shutdown();
    }
 
}
```

+ Создать потомка класса Thread и переопределить его метод run();
+ Создать объект класса Thread, передав ему в конструкторе экземпляр класса, реализующего интерфейс Runnable.
  Эти интерфейс содержит метод run(), который будет выполняться в новом потоке.
  Поток закончит выполнение, когда завершится его метод run().
+ Вызвать метод submit() у экземпляра класса реализующего интерфейс ExecutorService,
  передав ему в качестве параметра экземпляр класса реализующего интерфейс Runnable или Callable (содержит метод call(), в котором описывается логика выполнения).

[к оглавлению](#multithreading)

## Как работают методы sleep yield wait notify и notifyAll

+ sleep - усыпляет поток, не освобождает lock объект
+ wait - усыпляет поток, освобождает lock объект
+ notify - будит последний стоящий в очереди поток
+ notifyAll - будит все стоящие в очереди объекты
+ yield - это попытка уступить очередь потокам, решает jvm.

  yield() – текущая нить «пропускает свой ход». Нить из состояния running переходит в состояние ready, а Java-машина приступает к выполнению следующей нити. Состояния running & ready – это подсостояния состояния RUNNABLE. Текущая нить «пропускает свой ход» — Java сразу переключается на выполнение следующей нити.


с помощью этих методов происходит взаимодействия потоков исполнения, могут быть вызваны только из синхронизированного контекста.
sleep переводит поток в состояние ожидания на заданный промежуток времени
wait - уступает монитор и переводит поток в ожидание
notify - возобновляет исполнение потока, из которых был вызван wait для того же монитора
notifyAll возобновляет исполнение всех потоков, из которых был вызван wait для того же объекта
yield() в потоке отдает квант времени другому потоку, текущий поток перемещается вниз очереди потоков с равным приоритетом, состояние потока остается RUNNABLE.
например, когда поток ожидает наступления какого-либо события и необходимо чтобы проверка его наступления происходила как можно чаще.
```java
//Пока в очереди нет сообщений
while(!msgQueue.hasMessages())
{
//Передать управление другим потокам
Thread.yield();
}
```

[к оглавлению](#multithreading)
## Объясните следующие термины монитор мьютекс критическая секция
Мьютекс (или взаимное исключение) – это самый простой тип синхронизатора – он гарантирует, что только один поток может одновременно выполнять критическую часть компьютерной программы.
Мьютекс — это специальный объект для синхронизации потоков. Он «прикреплен» к каждому объекту в Java. задача мьютекса — обеспечить такой механизм, чтобы доступ к объекту в определенное время был только у одного потока. Условно классический мьютекс можно представить в виде переменной, которая может находиться в двух состояниях: в заблокированном и в незаблокированном. При входе в свою критическую секцию поток вызывает функцию перевода мьютекса в заблокированное состояние, при этом поток блокируется до освобождения мьютекса, если другой поток уже владеет им. При выходе из критической секции поток вызывает функцию перевода мьютекса в незаблокированное состояние.

Монитор — это дополнительная «надстройка» над мьютексом.
Monitor - высокоуровневый механизм взаимодействия и синхронизации процессов, обеспечивающий доступ к неразделяемым ресурсам.
Когда поток запрашивает блокировку - входит в монитор - все остальные путающиеся войти в монитор будут приостановлены (ожидать монитор) пока первый не отпустит монитор - выйдет из монитора.

Критическая секция — участок исполняемого кода программы, в котором производится доступ к общему ресурсу (данным или устройству), который не должен быть одновременно использован более чем одним потоком выполнения. При нахождении в критической секции двух (или более) потоков возникает состояние «гонки» («состязания»).

+ synchronized:
```java
private Object mutex = new Object();

    @Override
    public int getNextSequence() {
        synchronized (mutex) {
            return super.getNextSequence();
        }
    }
```
+ ReentrantLock:
```java
 private ReentrantLock mutex = new ReentrantLock();

    @Override
    public int getNextSequence() {
        try {
            mutex.lock();
            return super.getNextSequence();
        } finally {
            mutex.unlock();
        }
    }
```
+ Semaphore:

  Как и ReentrantLock, класс Semaphore также был представлен в Java 1.5.

В то время как в случае мьютекса только один поток может получить доступ к критическому разделу, Семафор позволяет фиксированному числу потоков получить доступ к критическому разделу. Поэтому мы также можем реализовать мьютекс, установив количество разрешенных потоков в семафоре равным одному.

Теперь давайте создадим еще одну потокобезопасную версию Генератора последовательностей с использованием Семафора

Класс ReentrantLock был представлен в Java 1.5. Он обеспечивает большую гибкость и контроль, чем подход synchronized keyword.
```java
private Semaphore mutex = new Semaphore(1);

    @Override
    public int getNextSequence() {
        try {
            mutex.acquire();
            return super.getNextSequence();
        } catch (InterruptedException e) {
            // exception handling code
        } finally {
            mutex.release();
        }
    }
```

[к оглавлению](#multithreading)
## Как работает join
Когда поток вызывает join() для другого потока, текущий работающий поток будет ждать, пока другой поток,
к которому он присоединяется, не будет завершён:

```java
    void join()        
    void join(long millis) 
    void join(long millis, int nanos) 
```

[к оглавлению](#multithreading)
## Что такое deadlock приведите примеры
взаимная блокировка
1 поток заблокировал монитор А
2 поток заблокировал монитор Б
1 поток пытается войти и в монитор Б (а он заблокирован)
2 поток пытается войти и в монитор А (а он заблокирован)

```java
public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
	synchronized (fromAccount) {
		synchronized (toAccount) {
			if (fromAccount.getBalance().compareTo(amount) < 0)
				throw new InsufficientFundsException();
			else {
				fromAccount.debit(amount);
				toAccount.credit(amount);
			}
		}
	}
}
```

[к оглавлению](#multithreading)
## Назовите различия между collectionssynchronizedmap new hashmap и concurrenthashmap
ConcurrentHashMap был введен в JDK 5.
На уровне объекта блокировки нет, Блокировка гораздо более детализирована. Для a ConcurrentHashMap блокировки могут быть на уровне сегмента hashmap.
Эффект низкоуровневой блокировки заключается в том, что у вас могут быть одновременные программы чтения и записи, что невозможно для синхронизированных коллекций. Это приводит к гораздо большей масштабируемости.
ConcurrentHashMap не выдает, ConcurrentModificationException если один поток пытается изменить его, в то время как другой перебирает его.
synchronisedHashmap
Он будет поддерживать блокировку на уровне объекта. Поэтому, если вы хотите выполнить какую-либо операцию, такую как put / get, вам нужно сначала получить блокировку. В то же время другим потокам не разрешается выполнять какие-либо операции. Таким образом, только один поток может работать с этим. Так что время ожидания здесь увеличится. Можно сказать, что производительность относительно низкая, если сравнивать с ConcurrentHashMap.
ConcurrentHashMap
Он будет поддерживать блокировку на уровне сегмента. Он имеет 16 сегментов и поддерживает уровень параллелизма как 16 по умолчанию. Таким образом, одновременно 16 потоков могут работать с ConcurrentHashMap. Более того, операция чтения не требует блокировки. Таким образом, любое количество потоков может выполнить операцию get.
Если thread1 хочет выполнить операцию put в сегменте 2, а thread2 хочет выполнить операцию put в сегменте 4, то это разрешено здесь. Значит, 16 потоков могут одновременно выполнять операцию обновления (вставки / удаления) в ConcurrentHashMap.
Так что время ожидания здесь будет меньше. Следовательно, производительность относительно лучше, чем synchronizedHashmap.

Оба являются синхронизированными версиями HashMap c различиями в функциональности и внутренней структуре.
**ConcurrentHashMap** состоит из внутренних сегментов, которые могут рассматриваться как независимые HashMap’ы концептуально.
Все эти сегменты могу быть заблокированы отдельными потоками выполняемыми одновременно.
Таким образом несколько потоков могу одновременно получить/положить пары key-value из ConcurrentHashMap без блокирования/ожидания друг друга.
использует очень сложные методы для уменьшения необходимости синхронизации
и обеспечения параллельного доступа для чтения несколькими потоками без синхронизации и,
что более важно, предоставляет Iterator, который не требует синхронизации,
и даже позволяет изменять Карту во время (хотя он **не гарантирует, будут ли возвращены элементы, вставленные во время итерации**).

**Из Collections.synchronizedMap()** мы получаем синхронизированную версию HashMap и доступ в блокировании образом.
Это означает то что если несколько потоков пытаются получить доступ к synchronizedMap в одно и тоже время
им будет позволено взять/положить пары key-value по одному синхронизированному образу.
они используют очень простую синхронизацию, а это означает, что только один поток может одновременно получить доступ к карте.
Это не большая проблема, когда у вас есть простые вставки и поиск (если вы не делаете это очень интенсивно),
но **становится большой проблемой, когда вам нужно перебирать всю карту**,
что может занять много времени для большой Карты. В то время как один поток делает это, все остальные должны ждать,
хотят ли они вставлять или искать что-либо.

[к оглавлению](#multithreading)
## Различия в интерфейсах runnable и callable

+ Интерфейс Runnable появился в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки java.util.concurrent;
+ Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод run().
  Классы, реализующие интерфейс Callable - метод call();
+ Метод Runnable.run() не возвращает никакого значения, Callable.call() возвращает объект Future,
  который может содержать результат вычислений;
+ Метод run() не может выбрасывать проверяемые исключения, в то время как метод call() может.

[к оглавлению](#multithreading)
## Различия между isinterrupted interrupted
Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания.
Прерывание потока вызовом Thread.interrupt() устанавливает этот флаг.

Методы Thread.interrupted() и isInterrupted() позволяют проверить, является ли поток прерванным.
+ Когда прерванный поток проверяет статус прерывания, вызывая статический метод Thread.interrupted(),
  статус прерывания сбрасывается. Фактически, это еще и ограничивает возможность снять флаг прерывания у других тредов (нельзя "украсть" прерывание другого треда).

+ Нестатический метод isInterrupted() используется одним потоком для проверки статуса прерывания у другого потока,
  не изменяя флаг прерывания.

[к оглавлению](#multithreading)
## Что происходит при вызове threadinterrupt
Устанавливает флаг прерывания.

[к оглавлению](#multithreading)
## Перечислите все причины по которым может выскочить interruptedexception
+ Поток прерван во время ожидания на мониторе
+ Поток прерван во время засыпания
+ Поток прерван во время захвата ReentrantLock через lockInterruptibly
+ Поток прерван во время ожидания в CountDownLatch через await
+ Поток прерван во время ожидания в CyclicBarrier через await
+ Поток прерван во время ожидания в Condition через await
+ Поток прерван во время захвата попытки в Semaphore через acquireUninterruptibly
+ Поток прерван во время получения значения в Future через get
+ Поток прерван во время обмена значенимя в Exchanger через exchange
+ Поток прерван во время блокирующих операций с BlockingQueue
+ Поток прерван во время работы с I/O через InterruptableChannel

В общем, почти любой блокирующий метод выбрасывает это исключение.

[к оглавлению](#multithreading)
## Назовите отличия synchronize и reentrantlock
В Java 5 появился интерфейс Lock предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов.
**ReentrantLock** – распространённая реализация Lock, которая предоставляет Lock с таким же базовым поведением и семантикой,
как у synchronized, но расширенными возможностями, такими как опрос о блокировании (lock polling),
ожидание блокирования заданной длительности и прерываемое ожидание блокировки.
Кроме того, он предлагает гораздо более высокую эффективность функционирования в условиях жесткой состязательности.

Что понимается под блокировкой с повторным входом (reentrant)? Просто то, что есть подсчет сбора данных, связанный с блокировкой,
и если поток, который удерживает блокировку, снова ее получает, данные отражают увеличение,
и тогда для реального разблокирования нужно два раза снять блокировку. Это аналогично семантике synchronized;
если поток входит в синхронный блок, защищенный монитором, который уже принадлежит потоку, потоку будет разрешено
дальнейшее функционирование, и блокировка не будет снята, когда поток выйдет из второго (или последующего) блока synchronized,
она будет снята только когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.

```java
Lock lock = new ReentrantLock();

lock.lock();
try { 
  // update object state
}
finally {
  lock.unlock(); 
}
```

Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized.
Это значит, что когда много потоков соперничают за право получения блокировки,
общая пропускная способность обычно лучше у ReentrantLock, чем у synchronized.
JVM требуется меньше времени на установление очередности потоков и больше времени на непосредственно выполнение.
У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке
(иначе, если бы защищенный код выбросил исключение, блокировка не была бы снята).
Используя синхронизацию, JVM гарантирует, что блокировка автоматически снимаются.
Резюмируя можно сказать, что когда состязания за блокировку нет либо оно очень мало, то synchronized возможно будет быстрее.
Если присутствует заметное состязание за доступ к ресурсу, то скорее всего ReentrantLock даст некое преимущество.


Объект класса ReentrantLock решает те же задачи, что и блок synchronized. Поток висит на вызове метода lock() в ожидании своей очереди занять этот объект. Владеть локом, как и находиться внутри блока synchronized может только один поток одновременно. unlock(), подобно выходу из блока синхронизации, освобождает объект-монитор для других потоков.В отличие от блока синхронизации, ReentrantLock дает расширенный интерфейс для получения информации о состоянии блокировки. Методы лока позволяют еще до блокировки узнать, занят ли он сейчас, сколько потоков ждут его в очереди, сколько раз подряд текущий поток завладел им.Шире и возможные режимы блокировки. Кроме обычного ожидающего lock(), вариант tryLock() с параметром ожидает своей очереди только заданное время, а без параметра - вообще не ждет, а только захватывает свободный лок.Еще одно отличие - свойство fair. Лок с этим свойством обеспечивает «справедливость» очереди: пришедший раньше поток захватывает объект раньше. Блок synchronized не дает никаких гарантий порядка.
Lock - интерфейс который имплементируется классом ReentrantLock.
Так же как ключевое слово synchronised, Lock нужен для достижения синхронизации между потоками.
В отличие от syncronized блокировок,ReentrantLock позволяет более гибко выбирать моменты снятия и получения блокировки т.к. использует обычные Java вызовы. Также ReentrantLock позволяет получить информацию о текущем состоянии блокировки, разрешает «ожидать» блокировку в течение определенного времени. Поддерживает правильное рекурсивное получение и освобождение блокировки для одного потока. Если вам необходимы честные блокировки (соблюдающие очередность при захвате монитора) — ReentrantLock также снабжен этим механизмом.
Несмотря на то, что synchronized и ReentrantLock блокировки очень похожи — реализация на уровне JVM отличается довольно сильно.
Не вдаваясь в подробности JMM: использовать ReentrantLock вместо предоставляемой JVM syncronized блокировки стоит только в том случае, если у вас очень часто происходит битва потоков за монитор. В случае, когда в syncronized метод _обычно_ попадает лишь один поток — производительность ReentrantLock уступает механизму блокировок JVM.

[к оглавлению](#multithreading)

## Приведите наиболее существенное отличие между countdownlatch и barrier
+ **CountDownLatch** (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор,
  пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены»,
  чтобы продолжить свою деятельность.
  В конструктор CountDownLatch(int count) обязательно передается количество операций, которое должно быть выполнено,
  чтобы замок «отпустил» заблокированные потоки.
  Для ожидания по самоблокировке в потоке исполнения вызывается метод await(), общие формы которого приведены ниже.

```java
void await() throws InterruptedException
boolean await(long , TimeUnit _) throws InterruptedException
```

В первой форме ожидание длится до тех пор, пока отсчет, связанный с вызывающим объектом типа CountDownLatch, не достигнет нуля.
А во второй форме ожидание длится только в течение определенного периода времени, определяе­мого параметром ожидание.

Метод await() возвращает ло­гическое значение false, если достигнут предел времени ожидания, или логиче­ское значение true, если обратный отсчет достигает нуля.

Чтобы известить о событии, следует вызвать метод countDown().
Всякий раз, когда вызывается метод countDown(), отсчет, связанный с вызывающим объектом, уменьшается на единицу.

```java
void countDown()
```

    Примером CountDownLatch из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество человек, экскурсия не начнется.

+ **CyclicBarrier** реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации,
  в которой указанное количество параллельных потоков встречается и блокируется.
  Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него),
  и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются».
  В конструкторы барьера CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction)
  обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие,
  которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».

CyclicBarrier является альтернативой метода join(), который «собирает» потоки только после того, как они выполнились.

CyclicBarrier похож на CountDownLatch, но главное различие между ними в том,
что использовать «замок» можно лишь единожды - после того, как его счётчик достигнет нуля,
а «барьер» можно использовать неоднократно, даже после того, как он «сломается».

[к оглавлению](#multithreading)

## Отличие threadstart и threadrun
Несмотря на то, что start() вызывает метод run() внутри себя, это не то же самое, что просто вызов run().
Если **run()** вызывается как обычный метод, то он **вызывается в том же потоке и никакой новый поток не запускается**,
как это происходит, в случае, когда вы вызываете метод start().

1 запустит выполнение таска в новом потоке
2 таск запустится в текущем потоке

[к оглавлению](#multithreading)
## Объясните ключевое слово volatile

**volatile** - этот модификатор вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной.
Если переменная примитивного типа – этого будет достаточно для обеспечения потокобезопасности.
Если же переменная является ссылкой на объект – синхронизировано будет исключительно значение этой ссылки.
Все же данные, содержащиеся в объекте, синхронизированы не будут!

volatile(«изменчивый») означает, что значение переменной будет изменяться разными потоками.
Модификатор volatile накладывает некоторые дополнительные условия на чтение/запись переменной.
Операции чтения/записи volatile переменной являются атомарными.
Результат операции записи значения в volatile переменную одним потоком, становится виден всем другим потокам, которые используют эту переменную для чтения из нее значения.

[к оглавлению](#multithreading)
## Расскажите про приоритеты потока

Приоритеты потоков используются планировщиком потоков для принятия решений о том,
когда какому из потоков будет разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора,
чем низкоприоритетные. Практически объем времени процессора,
который получает поток, часто зависит от нескольких факторов помимо его приоритета.

Чтобы установить приоритет потока, используется метод класса Thread: final void setPriority(int level).
Значение level изменяется в пределах от Thread.MIN_PRIORITY = 1 до Thread.MAX_PRIORITY = 10.
Приоритет по умолчанию - Thread.NORM_PRlORITY = 5.

Получить текущее значение приоритета потока можно вызвав метод: final int getPriority() у экземпляра класса Thread.

Мера важности потока для планировщика
Приоритет потока - это целое число, которое определяет поведение данного потока по отношению к остальным потокам. Приоритет потока нужен для переключения контекста (принятия решения перехода от одного потока к другому)
Поток может уступить управление
Поток исполнения может быть вытеснен более приоритетным (высокоприоритетный поток выполняется, как только ему это потребуется)
метод setPriotity(int приоритет) от 1 до 10

Планировщик потоков использует приоритеты, чтобы принять решение, когда разрешить исполнение каждому потоку.

[к оглавлению](#multithreading)
## Что такое потоки демоны
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы.
Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается
в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода
setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить,
является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного
потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(),
не обращая внимания на то, что поток-демон еще работает.

+ Когда создается новый поток, он наследует статус демона своего родителя.
+ Когда все потоки, не являющиеся демонами, заканчивают работу, JVM останавливается, а все оставшиеся потоки демонов удаляются:
  + наконец блоки не выполняются,
  + стеки не разматываются - JVM просто выходит.

По этой причине потоки демонов следует использовать с осторожностью,
и их опасно использовать для задач, которые могут выполнять любые операции ввода-вывода.

[к оглавлению](#multithreading)
## Назовите все возможные состояния потока
Потоки могут находиться в одном из следующих состояний:

+ Новый (New). После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start().
  В этом состоянии поток не считается живым.
+ Работоспособный (Runnable). Поток переходит в состояние Работоспособный, когда вызывается метод start().
  Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован.
  Когда поток находится в этом состоянии, он считается живым.
+ Работающий (Running). Поток переходит из состояния Работоспособный в состояние Работающий,
  когда Планировщик потоков выбирает его как работающий в данный момент.
+ Живой, но не работоспособный (Alive, but not runnable). Поток может быть живым, но не работоспособным по нескольким причинам:
+ Ожидание (Waiting). Поток переходит в состояние Ожидания, вызывая метод wait(). Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.
+ Сон (Sleeping). Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.
+ Блокировка (Blocked). Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта. В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.
+ Мёртвый (Dead). Поток считается мёртвым, когда его метод run() полностью выполнен. Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().

[к оглавлению](#multithreading)
## Что такое race condition
гонка
есть несколько потоков и общие ресурсы

**Состояние гонки (race condition)** - ошибка проектирования многопоточной системы или приложения,
при которой эта работа напрямую зависит от того, в каком порядке выполняются потоки.
Состояние гонки возникает когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток:
поведение кода изменяется, из-за чего возникают недетерменированные ошибки.

Распространённые способы решения:

+ Использование локальной копии — копирование разделяемой переменной в локальную переменную потока.
  Этот способ работает только тогда, когда переменная одна и копирование производится атомарно (за одну машинную команду),
  использование volatile.
+ Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании ключевого слова synchronized).
+ Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в синхронизированном блоке.
  С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться от слишком больших синхронизированных блоков.
  Очевидных способов выявления и исправления состояний гонки не существует.
  Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.

[к оглавлению](#multithreading)
## Что такое thread local переменная
**ThreadLocal** - класс, позволяющий имея одну переменную, иметь различное её значение для каждого из потоков.
У каждого потока - т.е. экземпляра класса Thread - есть ассоциированная с ним таблица ThreadLocal-переменных.
Ключами таблицы являются cсылки на объекты класса ThreadLocal,
а значениями - ссылки на объекты, «захваченные» ThreadLocal-переменными,
т.е. ThreadLocal-переменные отличаются от обычных переменных тем,
что у каждого потока свой собственный, индивидуально инициализируемый экземпляр переменной.
Доступ к значению можно получить через методы get() или set().

Например, если мы объявим ThreadLocal-переменную: ThreadLocal<Object> locals = new ThreadLocal<Object>();.
А затем, в потоке, сделаем locals.set(myObject), то ключом таблицы будет ссылка на объект locals,
а значением - ссылка на объект myObject. При этом для другого потока существует возможность «положить» внутрь locals другое значение.

Следует обратить внимание, что ThreadLocal изолирует именно ссылки на объекты, а не сами объекты.
Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.

Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках,
то инициализация такой переменной должна происходить в том же потоке, в котором она будет использоваться.
Ошибкой является инициализация такой переменной (вызов метода set()) в главном потоке приложения,
потому как в данном случае значение, переданное в методе set(), будет «захвачено» для главного потока,
и при вызове метода get() в целевом потоке будет возвращен null.

[к оглавлению](#multithreading)
## Что такое futuretask
**FutureTask** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении.
Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления,
методами для запроса состояния вычисления и извлечения результатов.
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, если вычисление ещё не завершено.
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable.
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

```java
        // создаем 2 future таска для 2х callable объектов
        FutureTask<String> futureTask1 = new FutureTask<String>(callable1);
        FutureTask<String> futureTask2 = new FutureTask<String>(callable2);
 
        // екзекьютор с размером пула в 2 потока
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // стартуем
        executor.execute(futureTask1);
        executor.execute(futureTask2);
         
        // выполняем в бесконечном цикле, пока 
        // executor service не закончит выполнение всех future тасков
        while (true) {
            try {
                if(futureTask1.isDone() && futureTask2.isDone()){
                    System.out.println("Done");
                    // заканчиваем работу executor service
                    executor.shutdown();
                    return;
                }
                 
                if(!futureTask1.isDone()){
                // ждем, пока future task не закончит выполнение
                System.out.println("Результат выполнения FutureTask1 = " + futureTask1.get());
                }
                 
                System.out.println("Ждем, пока FutureTask2 не закончит свое выполнение");
                String s = futureTask2.get(200L, TimeUnit.MILLISECONDS);
                if(s !=null){
                    System.out.println("Результат выполнения FutureTask2 = " + s);
                }
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }catch(TimeoutException e){
                //оставим пустым
            }
```

[к оглавлению](#multithreading)
## Что такое thread pool
Создание потока является затратной по времени и ресурсам операцией.
Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно.
Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован механизм пула потоков (thread pool),
который создаётся во время запуска приложения и в дальнейшем потоки для обработки запросов берутся и переиспользуются уже из него.
Таким образом, появляется возможность не терять потоки, сбалансировать приложение по количеству потоков и частоте их создания.

Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет создавать различные типы пула потоков:

+ Executor - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;
+ ExecutorService - расширенный интерфейс пула, с возможностью завершения всех потоков;
+ AbstractExecutorService - базовый класс пула, реализующий интерфейс ExecutorService;
+ Executors - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;
+ ThreadPoolExecutor - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;
+ ForkJoinPool - пул для выполнения задач типа ForkJoinTask;
+ ... и другие.

Методы Executors для создания пулов:

+ newCachedThreadPool() - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул.
  Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен.
  Предназначен для выполнения множество небольших асинхронных задач;
+ newCachedThreadPool(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ newFixedThreadPool(int nThreads) - создает пул на указанное число потоков.
  Если новые задачи добавлены, когда все потоки активны, то они будут сохранены в очереди для выполнения позже.
  Если один из потоко завершился из-за ошибки, на его место будет запущен другой поток.
  Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown().
+ newFixedThreadPool(int nThreads, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ newSingleThreadScheduledExecutor() - однопотоковый пул с возможностью выполнять задачу через указанное время или выполнять периодически.
  Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи будет создан новый поток.
+ newSingleThreadScheduledExecutor(ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ newScheduledThreadPool(int corePoolSize) - пул для выполнения задач через указанное время или переодически;
+ newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory) - аналогично предыдущему, но с собственной фабрикой потоков;
+ unconfigurableExecutorService(ExecutorService executor) - обертка на пул, запрещающая изменять его конфигурацию;


[к оглавлению](#multithreading)
## Что такое semaphore
**Semaphore** – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор.
Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора,
когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается.
Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока.
Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.

[к оглавлению](#multithreading)
## Чем отличается submit от execute у executorservices
Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница.
+ **execute**(Runnable command) определён в интерфейсе Executor и выполняет поданную задачу и ничего не возвращает.
+ **submit()** – перегруженный метод, определённый в интерфейсе ExecutorService.
  Способен принимать задачи типов Runnable и Callable и возвращать объект Future,
  который можно использовать для контроля и управления процессом выполнения, получения его результата.

[к оглавлению](#multithreading)
## Чем отличается shutdown от shutdownNow у threadpoolexecutor
1) void shutdown(): пул перестает принимать новые задачи, но дорабатывает все уже стоящие в очереди.
2) List<Runnable> shutdownNow(): пул прерывает текущие задачи (thread.interrupt) и возвращает очередь ждавших ис

[к оглавлению](#multithreading)
## Как создать threadpool у executorservice только на 1 на 5 на неограниченное количество потоков
Executors.newFixedThreadPool(5)
newSingleThreadExecutor()
CachedThreadPool - создает потоков сколько требуется
Начиная с Java 1.5 Java API предоставляет фреймворк Executor, который позволяет вам создавать различные пулы нитей, например single thread pool, который обрабатывает только одно задание за единицу времени, fixed thread pool, пул с фиксированным количеством нитей, и cached thread pool, расширяемый пул, подходящий для приложений с множеством недолгих заданий.

[к оглавлению](#multithreading)
## Что такое readwritelock
Интерфейс ReadWriteLock предлагает другой тип блокировок — отдельную для чтения, и отдельную для записи. Этот интерфейс был добавлен из соображения, что считывать данные (любому количеству потоков) безопасно до тех пор, пока ни один из них не изменяет переменную. Таким образом, блокировку для чтения (read-lock) может удерживать любое количество потоков до тех пор, пока не удерживает блокировка для записи (write-lock). Такой подход может увеличить производительность в случае, когда чтение используется гораздо чаще, чем запись.

**ReadWriteLock** – это интерфейс расширяющий базовый интерфейс Lock.
Используется для улучшения производительности в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи).
Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор пока не появится записывающий.
Блокировка записи является эксклюзивной.

Существует реализующий интерфейс ReadWriteLock класс ReentrantReadWriteLock,
который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.

```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock rLock = rwLock.readLock();
Lock wLock = rwLock.writeLock();

wLock.lock();
try {
    // exclusive write
} finally {
    wLock.unlock();
}
        
rLock.lock();
try {
    // shared reading
} finally {
    rLock.unlock();
}
```

[к оглавлению](#multithreading)
## В чём отличие thread от futuretask В чём отличие threadinterrupt и futuretaskcancel

**FutureTask** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении.
Этот класс предоставляет базовую реализацию Future, с методами для запуска и остановки вычисления,
методами для запроса состояния вычисления и извлечения результатов.
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован,
если вычисление ещё не завершено.
Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable.
Так как FutureTask реализует Runnable, его можно передать в Executor на выполнение.

у Future есть метод Future.cancel(boolean), который должен отменить выполнение задачи.
В недрах реализации FutureTask выполняется код:

```java
if (mayInterruptIfRunning) {
Thread r = runner;
if (r != null)
r.interrupt(); }
```

1) thread.interrupt() - посылает потоку сигнал о прерывании
2) task.cancel (true/false) имеет два варианта, если задание уже исполняется: прерывать поток (true) или уже не мешать (false)

[к оглавлению](#multithreading)
## Расскажите про шаблон проектирования producer consumer
Шаблон producer/consumer (производитель/потребитель) - простая и базовая реализация обмена данными между несколькими потоками. Поток-производитель отправляет объекты на условную обработку, потоки-потребители асинхронно принимают и обрабатывают их.Общий вид решения выглядит так. Продюсер отправляет объекты в специальную коллекцию - буфер. Когда потребитель освобождается, он отправляет запрос на извлечение одного объекта из буфера. Если буфер пуст, потребитель блокируется и ждет, если буфер переполнен - ждет производитель.

Шаблон заключается в разделении потоков по виду их деятельность на поставщиков и потребителей.
Поставщики и потребители не общаются друг с другом напрямую, вместо этого передавая работу через общую очередь.
Такой подход позволяет независимо разрабатывать поставщиков и потребителей,
так как они не знают друг о друге, но знают только формат общения.
Другое преимущество - возможность поставщиков и потребителей работать на разной скорости:
медленный потребитель не будет тормозить быстрого поставщика.


[к оглавлению](#multithreading)
